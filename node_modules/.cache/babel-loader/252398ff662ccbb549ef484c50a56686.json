{"ast":null,"code":"'use strict';\n\nvar Utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\nvar defaults = {\n  delimiter: '&',\n  depth: 5,\n  arrayLimit: 20,\n  parameterLimit: 1000,\n  strictNullHandling: false,\n  plainObjects: false,\n  allowPrototypes: false,\n  allowDots: false,\n  decoder: Utils.decode\n};\n\nvar parseValues = function parseValues(str, options) {\n  var obj = {};\n  var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n  for (var i = 0; i < parts.length; ++i) {\n    var part = parts[i];\n    var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n    var key, val;\n\n    if (pos === -1) {\n      key = options.decoder(part);\n      val = options.strictNullHandling ? null : '';\n    } else {\n      key = options.decoder(part.slice(0, pos));\n      val = options.decoder(part.slice(pos + 1));\n    }\n\n    if (has.call(obj, key)) {\n      obj[key] = [].concat(obj[key]).concat(val);\n    } else {\n      obj[key] = val;\n    }\n  }\n\n  return obj;\n};\n\nvar parseObject = function parseObject(chain, val, options) {\n  if (!chain.length) {\n    return val;\n  }\n\n  var root = chain.shift();\n  var obj;\n\n  if (root === '[]') {\n    obj = [];\n    obj = obj.concat(parseObject(chain, val, options));\n  } else {\n    obj = options.plainObjects ? Object.create(null) : {};\n    var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n    var index = parseInt(cleanRoot, 10);\n\n    if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {\n      obj = [];\n      obj[index] = parseObject(chain, val, options);\n    } else {\n      obj[cleanRoot] = parseObject(chain, val, options);\n    }\n  }\n\n  return obj;\n};\n\nvar parseKeys = function parseKeys(givenKey, val, options) {\n  if (!givenKey) {\n    return;\n  } // Transform dot notation to bracket notation\n\n\n  var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey; // The regex chunks\n\n  var brackets = /(\\[[^[\\]]*])/;\n  var child = /(\\[[^[\\]]*])/g; // Get the parent\n\n  var segment = brackets.exec(key);\n  var parent = segment ? key.slice(0, segment.index) : key; // Stash the parent if it exists\n\n  var keys = [];\n\n  if (parent) {\n    // If we aren't using plain objects, optionally prefix keys\n    // that would overwrite object prototype properties\n    if (!options.plainObjects && has.call(Object.prototype, parent)) {\n      if (!options.allowPrototypes) {\n        return;\n      }\n    }\n\n    keys.push(parent);\n  } // Loop through children appending to the array until we hit depth\n\n\n  var i = 0;\n\n  while ((segment = child.exec(key)) !== null && i < options.depth) {\n    i += 1;\n\n    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n      if (!options.allowPrototypes) {\n        return;\n      }\n    }\n\n    keys.push(segment[1]);\n  } // If there's a remainder, just add whatever is left\n\n\n  if (segment) {\n    keys.push('[' + key.slice(segment.index) + ']');\n  }\n\n  return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n  var options = opts || {};\n\n  if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n    throw new TypeError('Decoder has to be a function.');\n  }\n\n  options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n  options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n  options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n  options.parseArrays = options.parseArrays !== false;\n  options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n  options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n  options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n  options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n  options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n  options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n  if (str === '' || str === null || typeof str === 'undefined') {\n    return options.plainObjects ? Object.create(null) : {};\n  }\n\n  var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n  var obj = options.plainObjects ? Object.create(null) : {}; // Iterate over the keys and setup the new object\n\n  var keys = Object.keys(tempObj);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    var newObj = parseKeys(key, tempObj[key], options);\n    obj = Utils.merge(obj, newObj, options);\n  }\n\n  return Utils.compact(obj);\n};","map":null,"metadata":{},"sourceType":"script"}