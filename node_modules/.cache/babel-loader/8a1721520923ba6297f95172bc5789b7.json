{"ast":null,"code":"var genobj = require('generate-object-property');\n\nvar genfun = require('generate-function');\n\nvar jsonpointer = require('jsonpointer');\n\nvar xtend = require('xtend');\n\nvar formats = require('./formats');\n\nvar get = function (obj, additionalSchemas, ptr) {\n  var visit = function (sub) {\n    if (sub && sub.id === ptr) return sub;\n    if (typeof sub !== 'object' || !sub) return null;\n    return Object.keys(sub).reduce(function (res, k) {\n      return res || visit(sub[k]);\n    }, null);\n  };\n\n  var res = visit(obj);\n  if (res) return res;\n  ptr = ptr.replace(/^#/, '');\n  ptr = ptr.replace(/\\/$/, '');\n\n  try {\n    return jsonpointer.get(obj, decodeURI(ptr));\n  } catch (err) {\n    var end = ptr.indexOf('#');\n    var other; // external reference\n\n    if (end !== 0) {\n      // fragment doesn't exist.\n      if (end === -1) {\n        other = additionalSchemas[ptr];\n      } else {\n        var ext = ptr.slice(0, end);\n        other = additionalSchemas[ext];\n        var fragment = ptr.slice(end).replace(/^#/, '');\n\n        try {\n          return jsonpointer.get(other, fragment);\n        } catch (err) {}\n      }\n    } else {\n      other = additionalSchemas[ptr];\n    }\n\n    return other || null;\n  }\n};\n\nvar formatName = function (field) {\n  field = JSON.stringify(field);\n  var pattern = /\\[([^\\[\\]\"]+)\\]/;\n\n  while (pattern.test(field)) field = field.replace(pattern, '.\"+$1+\"');\n\n  return field;\n};\n\nvar types = {};\n\ntypes.any = function () {\n  return 'true';\n};\n\ntypes.null = function (name) {\n  return name + ' === null';\n};\n\ntypes.boolean = function (name) {\n  return 'typeof ' + name + ' === \"boolean\"';\n};\n\ntypes.array = function (name) {\n  return 'Array.isArray(' + name + ')';\n};\n\ntypes.object = function (name) {\n  return 'typeof ' + name + ' === \"object\" && ' + name + ' && !Array.isArray(' + name + ')';\n};\n\ntypes.number = function (name) {\n  return 'typeof ' + name + ' === \"number\" && isFinite(' + name + ')';\n};\n\ntypes.integer = function (name) {\n  return 'typeof ' + name + ' === \"number\" && (Math.floor(' + name + ') === ' + name + ' || ' + name + ' > 9007199254740992 || ' + name + ' < -9007199254740992)';\n};\n\ntypes.string = function (name) {\n  return 'typeof ' + name + ' === \"string\"';\n};\n\nvar unique = function (array) {\n  var list = [];\n\n  for (var i = 0; i < array.length; i++) {\n    list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i]);\n  }\n\n  for (var i = 1; i < list.length; i++) {\n    if (list.indexOf(list[i]) !== i) return false;\n  }\n\n  return true;\n};\n\nvar isMultipleOf = function (name, multipleOf) {\n  var res;\n  var factor = (multipleOf | 0) !== multipleOf ? Math.pow(10, multipleOf.toString().split('.').pop().length) : 1;\n\n  if (factor > 1) {\n    var factorName = (name | 0) !== name ? Math.pow(10, name.toString().split('.').pop().length) : 1;\n    if (factorName > factor) res = true;else res = Math.round(factor * name) % (factor * multipleOf);\n  } else res = name % multipleOf;\n\n  return !res;\n};\n\nvar compile = function (schema, cache, root, reporter, opts) {\n  var fmts = opts ? xtend(formats, opts.formats) : formats;\n  var scope = {\n    unique: unique,\n    formats: fmts,\n    isMultipleOf: isMultipleOf\n  };\n  var verbose = opts ? !!opts.verbose : false;\n  var greedy = opts && opts.greedy !== undefined ? opts.greedy : false;\n  var syms = {};\n\n  var gensym = function (name) {\n    return name + (syms[name] = (syms[name] || 0) + 1);\n  };\n\n  var reversePatterns = {};\n\n  var patterns = function (p) {\n    if (reversePatterns[p]) return reversePatterns[p];\n    var n = gensym('pattern');\n    scope[n] = new RegExp(p);\n    reversePatterns[p] = n;\n    return n;\n  };\n\n  var vars = ['i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'x', 'y', 'z'];\n\n  var genloop = function () {\n    var v = vars.shift();\n    vars.push(v + v[0]);\n    return v;\n  };\n\n  var visit = function (name, node, reporter, filter, schemaPath) {\n    var properties = node.properties;\n    var type = node.type;\n    var tuple = false;\n\n    if (Array.isArray(node.items)) {\n      // tuple type\n      properties = {};\n      node.items.forEach(function (item, i) {\n        properties[i] = item;\n      });\n      type = 'array';\n      tuple = true;\n    }\n\n    var indent = 0;\n\n    var error = function (msg, prop, value) {\n      validate('errors++');\n\n      if (reporter === true) {\n        validate('if (validate.errors === null) validate.errors = []');\n\n        if (verbose) {\n          validate('validate.errors.push({field:%s,message:%s,value:%s,type:%s,schemaPath:%s})', formatName(prop || name), JSON.stringify(msg), value || name, JSON.stringify(type), JSON.stringify(schemaPath));\n        } else {\n          validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg));\n        }\n      }\n    };\n\n    if (node.required === true) {\n      indent++;\n      validate('if (%s === undefined) {', name);\n      error('is required');\n      validate('} else {');\n    } else {\n      indent++;\n      validate('if (%s !== undefined) {', name);\n    }\n\n    var valid = [].concat(type).map(function (t) {\n      if (t && !types.hasOwnProperty(t)) {\n        throw new Error('Unknown type: ' + t);\n      }\n\n      return types[t || 'any'](name);\n    }).join(' || ') || 'true';\n\n    if (valid !== 'true') {\n      indent++;\n      validate('if (!(%s)) {', valid);\n      error('is the wrong type');\n      validate('} else {');\n    }\n\n    if (tuple) {\n      if (node.additionalItems === false) {\n        validate('if (%s.length > %d) {', name, node.items.length);\n        error('has additional items');\n        validate('}');\n      } else if (node.additionalItems) {\n        var i = genloop();\n        validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i);\n        visit(name + '[' + i + ']', node.additionalItems, reporter, filter, schemaPath.concat('additionalItems'));\n        validate('}');\n      }\n    }\n\n    if (node.format && fmts[node.format]) {\n      if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name));\n      var n = gensym('format');\n      scope[n] = fmts[node.format];\n      if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name);else validate('if (!%s.test(%s)) {', n, name);\n      error('must be ' + node.format + ' format');\n      validate('}');\n      if (type !== 'string' && formats[node.format]) validate('}');\n    }\n\n    if (Array.isArray(node.required)) {\n      var checkRequired = function (req) {\n        var prop = genobj(name, req);\n        validate('if (%s === undefined) {', prop);\n        error('is required', prop);\n        validate('missing++');\n        validate('}');\n      };\n\n      validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true');\n      validate('var missing = 0');\n      node.required.map(checkRequired);\n      validate('}');\n\n      if (!greedy) {\n        validate('if (missing === 0) {');\n        indent++;\n      }\n    }\n\n    if (node.uniqueItems) {\n      if (type !== 'array') validate('if (%s) {', types.array(name));\n      validate('if (!(unique(%s))) {', name);\n      error('must be unique');\n      validate('}');\n      if (type !== 'array') validate('}');\n    }\n\n    if (node.enum) {\n      var complex = node.enum.some(function (e) {\n        return typeof e === 'object';\n      });\n      var compare = complex ? function (e) {\n        return 'JSON.stringify(' + name + ')' + ' !== JSON.stringify(' + JSON.stringify(e) + ')';\n      } : function (e) {\n        return name + ' !== ' + JSON.stringify(e);\n      };\n      validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false');\n      error('must be an enum value');\n      validate('}');\n    }\n\n    if (node.dependencies) {\n      if (type !== 'object') validate('if (%s) {', types.object(name));\n      Object.keys(node.dependencies).forEach(function (key) {\n        var deps = node.dependencies[key];\n        if (typeof deps === 'string') deps = [deps];\n\n        var exists = function (k) {\n          return genobj(name, k) + ' !== undefined';\n        };\n\n        if (Array.isArray(deps)) {\n          validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true');\n          error('dependencies not set');\n          validate('}');\n        }\n\n        if (typeof deps === 'object') {\n          validate('if (%s !== undefined) {', genobj(name, key));\n          visit(name, deps, reporter, filter, schemaPath.concat(['dependencies', key]));\n          validate('}');\n        }\n      });\n      if (type !== 'object') validate('}');\n    }\n\n    if (node.additionalProperties || node.additionalProperties === false) {\n      if (type !== 'object') validate('if (%s) {', types.object(name));\n      var i = genloop();\n      var keys = gensym('keys');\n\n      var toCompare = function (p) {\n        return keys + '[' + i + '] !== ' + JSON.stringify(p);\n      };\n\n      var toTest = function (p) {\n        return '!' + patterns(p) + '.test(' + keys + '[' + i + '])';\n      };\n\n      var additionalProp = Object.keys(properties || {}).map(toCompare).concat(Object.keys(node.patternProperties || {}).map(toTest)).join(' && ') || 'true';\n      validate('var %s = Object.keys(%s)', keys, name)('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)('if (%s) {', additionalProp);\n\n      if (node.additionalProperties === false) {\n        if (filter) validate('delete %s', name + '[' + keys + '[' + i + ']]');\n        error('has additional properties', null, JSON.stringify(name + '.') + ' + ' + keys + '[' + i + ']');\n      } else {\n        visit(name + '[' + keys + '[' + i + ']]', node.additionalProperties, reporter, filter, schemaPath.concat(['additionalProperties']));\n      }\n\n      validate('}')('}');\n      if (type !== 'object') validate('}');\n    }\n\n    if (node.$ref) {\n      var sub = get(root, opts && opts.schemas || {}, node.$ref);\n\n      if (sub) {\n        var fn = cache[node.$ref];\n\n        if (!fn) {\n          cache[node.$ref] = function proxy(data) {\n            return fn(data);\n          };\n\n          fn = compile(sub, cache, root, false, opts);\n        }\n\n        var n = gensym('ref');\n        scope[n] = fn;\n        validate('if (!(%s(%s))) {', n, name);\n        error('referenced schema does not match');\n        validate('}');\n      }\n    }\n\n    if (node.not) {\n      var prev = gensym('prev');\n      validate('var %s = errors', prev);\n      visit(name, node.not, false, filter, schemaPath.concat('not'));\n      validate('if (%s === errors) {', prev);\n      error('negative schema matches');\n      validate('} else {')('errors = %s', prev)('}');\n    }\n\n    if (node.items && !tuple) {\n      if (type !== 'array') validate('if (%s) {', types.array(name));\n      var i = genloop();\n      validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i);\n      visit(name + '[' + i + ']', node.items, reporter, filter, schemaPath.concat('items'));\n      validate('}');\n      if (type !== 'array') validate('}');\n    }\n\n    if (node.patternProperties) {\n      if (type !== 'object') validate('if (%s) {', types.object(name));\n      var keys = gensym('keys');\n      var i = genloop();\n      validate('var %s = Object.keys(%s)', keys, name)('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i);\n      Object.keys(node.patternProperties).forEach(function (key) {\n        var p = patterns(key);\n        validate('if (%s.test(%s)) {', p, keys + '[' + i + ']');\n        visit(name + '[' + keys + '[' + i + ']]', node.patternProperties[key], reporter, filter, schemaPath.concat(['patternProperties', key]));\n        validate('}');\n      });\n      validate('}');\n      if (type !== 'object') validate('}');\n    }\n\n    if (node.pattern) {\n      var p = patterns(node.pattern);\n      if (type !== 'string') validate('if (%s) {', types.string(name));\n      validate('if (!(%s.test(%s))) {', p, name);\n      error('pattern mismatch');\n      validate('}');\n      if (type !== 'string') validate('}');\n    }\n\n    if (node.allOf) {\n      node.allOf.forEach(function (sch, key) {\n        visit(name, sch, reporter, filter, schemaPath.concat(['allOf', key]));\n      });\n    }\n\n    if (node.anyOf && node.anyOf.length) {\n      var prev = gensym('prev');\n      node.anyOf.forEach(function (sch, i) {\n        if (i === 0) {\n          validate('var %s = errors', prev);\n        } else {\n          validate('if (errors !== %s) {', prev)('errors = %s', prev);\n        }\n\n        visit(name, sch, false, false, schemaPath);\n      });\n      node.anyOf.forEach(function (sch, i) {\n        if (i) validate('}');\n      });\n      validate('if (%s !== errors) {', prev);\n      error('no schemas match');\n      validate('}');\n    }\n\n    if (node.oneOf && node.oneOf.length) {\n      var prev = gensym('prev');\n      var passes = gensym('passes');\n      validate('var %s = errors', prev)('var %s = 0', passes);\n      node.oneOf.forEach(function (sch, i) {\n        visit(name, sch, false, false, schemaPath);\n        validate('if (%s === errors) {', prev)('%s++', passes)('} else {')('errors = %s', prev)('}');\n      });\n      validate('if (%s !== 1) {', passes);\n      error('no (or more than one) schemas match');\n      validate('}');\n    }\n\n    if (node.multipleOf !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name));\n      validate('if (!isMultipleOf(%s, %d)) {', name, node.multipleOf);\n      error('has a remainder');\n      validate('}');\n      if (type !== 'number' && type !== 'integer') validate('}');\n    }\n\n    if (node.maxProperties !== undefined) {\n      if (type !== 'object') validate('if (%s) {', types.object(name));\n      validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties);\n      error('has more properties than allowed');\n      validate('}');\n      if (type !== 'object') validate('}');\n    }\n\n    if (node.minProperties !== undefined) {\n      if (type !== 'object') validate('if (%s) {', types.object(name));\n      validate('if (Object.keys(%s).length < %d) {', name, node.minProperties);\n      error('has less properties than allowed');\n      validate('}');\n      if (type !== 'object') validate('}');\n    }\n\n    if (node.maxItems !== undefined) {\n      if (type !== 'array') validate('if (%s) {', types.array(name));\n      validate('if (%s.length > %d) {', name, node.maxItems);\n      error('has more items than allowed');\n      validate('}');\n      if (type !== 'array') validate('}');\n    }\n\n    if (node.minItems !== undefined) {\n      if (type !== 'array') validate('if (%s) {', types.array(name));\n      validate('if (%s.length < %d) {', name, node.minItems);\n      error('has less items than allowed');\n      validate('}');\n      if (type !== 'array') validate('}');\n    }\n\n    if (node.maxLength !== undefined) {\n      if (type !== 'string') validate('if (%s) {', types.string(name));\n      validate('if (%s.length > %d) {', name, node.maxLength);\n      error('has longer length than allowed');\n      validate('}');\n      if (type !== 'string') validate('}');\n    }\n\n    if (node.minLength !== undefined) {\n      if (type !== 'string') validate('if (%s) {', types.string(name));\n      validate('if (%s.length < %d) {', name, node.minLength);\n      error('has less length than allowed');\n      validate('}');\n      if (type !== 'string') validate('}');\n    }\n\n    if (node.minimum !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name));\n      validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum);\n      error('is less than minimum');\n      validate('}');\n      if (type !== 'number' && type !== 'integer') validate('}');\n    }\n\n    if (node.maximum !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name));\n      validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum);\n      error('is more than maximum');\n      validate('}');\n      if (type !== 'number' && type !== 'integer') validate('}');\n    }\n\n    if (properties) {\n      Object.keys(properties).forEach(function (p) {\n        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name);\n        visit(genobj(name, p), properties[p], reporter, filter, schemaPath.concat(tuple ? p : ['properties', p]));\n        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}');\n      });\n    }\n\n    while (indent--) validate('}');\n  };\n\n  var validate = genfun('function validate(data) {') // Since undefined is not a valid JSON value, we coerce to null and other checks will catch this\n  ('if (data === undefined) data = null')('validate.errors = null')('var errors = 0');\n  visit('data', schema, reporter, opts && opts.filter, []);\n  validate('return errors === 0')('}');\n  validate = validate.toFunction(scope);\n  validate.errors = null;\n\n  if (Object.defineProperty) {\n    Object.defineProperty(validate, 'error', {\n      get: function () {\n        if (!validate.errors) return '';\n        return validate.errors.map(function (err) {\n          return err.field + ' ' + err.message;\n        }).join('\\n');\n      }\n    });\n  }\n\n  validate.toJSON = function () {\n    return schema;\n  };\n\n  return validate;\n};\n\nmodule.exports = function (schema, opts) {\n  if (typeof schema === 'string') schema = JSON.parse(schema);\n  return compile(schema, {}, schema, true, opts);\n};\n\nmodule.exports.filter = function (schema, opts) {\n  var validate = module.exports(schema, xtend(opts, {\n    filter: true\n  }));\n  return function (sch) {\n    validate(sch);\n    return sch;\n  };\n};","map":null,"metadata":{},"sourceType":"script"}